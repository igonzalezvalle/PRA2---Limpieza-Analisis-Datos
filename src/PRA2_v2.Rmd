---
title: "Práctica 2: Limpieza y análisis de datos"
author: "Cristina Merino García de la Reina, Isabel González Valle"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: true
      smooth_scroll: true
    includes:
      in_header: PEC2-header.html
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_libraries, include=FALSE}
library(knitr)
library(stringr)
library(psych)
library(VIM)
library(graphics)
library(RColorBrewer)
library(coin)
library(ISLR)
library(MASS)
library(dplyr)
library(pROC)
library(faraway)
library(kableExtra)
library(ggplot2)
library(data.table)
library(agricolae)
library(kableExtra)
library(sampling)
library(corrplot)
library(leaflet)
library(cluster)
library(caret)
library(lubridate) #Para trabajar con fechas
library(DescTools) #Transformada de Box-Cox
library(randomForest)
require(caTools)
library(gridExtra) #para usar grid.arrange
```
<span style="color:darkblue"> <font size="20"> **Descripción** </font></span>

<div style="text-align: justify">**El objetivo de esta actividad será el tratamiento de un dataset, que puede ser el creado en la práctica 1 o bien cualquier dataset libre disponible en Kaggle (https://www.kaggle.com).**

**Siguiendo las principales etapas de un proyecto analítico, las diferentes tareas a realizar (y justificar) son las siguientes:**


******  
<h1><span style="color:darkblue"> **1. Descripción del dataset**  </span> </h1> 
******  
**¿Por qué es importante y qué pregunta/problema pretende responder?**  
  
Para esta práctica hemos buscado un dataset de los vuelos que fueron cancelados o que sufrieron retrasos en durante el año 2015 comunicados a través del Departamento de Estadísticas de Transportes de los Estados Unidos. Este conjunto de datos contiene la información correspondiente a los vuelos operados por las grandes compañías aéreas.  
Poder conocer y tener una referencia del motivo de los vuelos cancelados o retrasados es interesante para las personas que deben usar este medio de transporte. Se pueden analizar diferentes problemáticas, como la relación entre los vuelos retrasados y los días de la semana, así como identificar cuál puede ser el mejor mes para viajar, que aeropuerto debemos evitar y por último, buscaremos identificar cuál es la mejor compañía para viajar. Intentaremos dar respuesta a algunas de estas preguntas durante esta práctica.  
<https://www.kaggle.com/usdot/flight-delays>  
El tipo de licencia de este dataset es: *CC0 1.0 Universal (CC0 1.0) Public Domain Dedication* . Por lo tanto es público y puede ser utilizado libremente para el trabajo que vamos a realizar.  
El conjunto de datos elegido contiene 31 variables y casi 6 millones de observaciones, por lo que de cara a la práctica reduciremos la cantidad de datos, intentando que la muestra a utilizar represente el conjunto de datos original lo más fielmente posible, para ello utilizaremos las técnicas de muestreo que se estudiaron en el módulo anterior.  
Del mismo modo, eliminaremos aquellas variables que no aporten valor al estudio que vamos a realizar, reduciendo así la dimensionalidad del conjunto de datos.  
En cuanto a las variables del dataset, se tienen las siguientes:  
  *YEAR: Año del vuelo (2015)  
  *MONTH: Mes del vuelo  
  *DAY: Día del vuelo  
  *DAY_OF_WEEK: Día de la semana, donde el día 1=lunes y el 7=Domingo  
  *AIRLINE: Código de la aerolínea  
  *FLIGHT_NUMBER: Número de vuelo  
  *TAIL_NUMBER: Número de identificación de la aeronave  
  *ORIGIN_AIRPORT: Aeropuerto Origen  
  *DESTINATION_AIRPORT: Aeropuerto Destino  
  *SCHEDULED_DEPARTURE: Hora programada de salida en formato hhmm (55 -> 00:55)  
  *DEPARTURE_TIME: Hora de salida del vuelo en formato hhmm  
  *DEPARTURE_DELAY: Diferencia en minutos entre la salida programada y la real ( valores negativos identifican salidas del vuelo con antelaión)  
  *TAXI_OUT: Tiempo de rodaje del avión desde que deja la puerta de embarque hasta despegue.  
  *WHEELS_OFF: Hora en la que el avión despega, momento en el que las ruedas del avión dejan de tocar el suelo  
  *SCHEDULED_TIME: Tiempo programado de vuelo.  
  *ELAPSED_TIME: Tiempo total de vuelo contado desde el momento que el avión se pone en marcha hasta que para completamente en destino, es decir contando el rodaje en el aeropuerto.  
  *AIR_TIME: Tiempo desde despegue hasta aterrizaje  
  *DISTANCE: Distancia en millas  
  *WHEELS_ON: Hora en la que el avión toca tierra.  
  *TAXI_IN: Tiempo de rodaje en el aeropuerto destino hasta que el avión para completamente.  
  *SCHEDULED_ARRIVAL: Hora programada de llegada en formato hhmm  
  *ARRIVAL_TIME: Hora de llegada real en formato hhmm    
  *ARRIVAL_DELAY: Diferencia en minutos entre la salida programada y la real  
  *DIVERTED: Vuelo desviado (0-No, 1-Sí)
  *CANCELLED: Vuelo Cancelado (0-No, 1-Sí)
  *CANCELLATION_REASON: Motivo de cancelación (A-Carrier, B-Weather, C-National Air System, D-Security)
  *AIR_SYSTEM_DELAY: Tiempo de retraso por el motivo indicado  
  *SECURITY_DELAY: Tiempo de retraso por el motivo indicado  
  *AIRLINE_DELAY: Tiempo de retraso por el motivo indicado  
  *LATE_AIRCRAFT_DELAY: Tiempo de retraso por el motivo indicado  
  *WEATHER_DELAY: Tiempo de retraso por el motivo indicado    




```{r,echo=TRUE,eval=TRUE}
#Cargamos el dataset
vuelos <- read.csv("flights.csv", sep=c(","), header = TRUE)

head(vuelos)

```
  
Este conjunto de datos tiene un tamaño demasiado grande para algunas de las operaciones que necesitamos hacer y por este motivo hemos decidido realizar la práctica con un subconjunto del mismo. En el caso necesario, todos los cálculos se podrían repetir con el conjunto completo.

```{r,echo=TRUE,eval=TRUE}
#Reducción de la cantidad
set.seed(222)
index <- sample(1:nrow(vuelos), size=0.05*nrow(vuelos))
vuelos_reduc <- vuelos[index,]
str(vuelos_reduc)
```
  
Hemos visto los primeros valores que toman las variables del conjunto con los datos reducidos. Ahora veremos un pequeño resumen estadístico de dichas variables.

```{r,echo=TRUE,eval=TRUE}
summary(vuelos_reduc)
```
  
Nuestro conjunto de datos ahora tiene una dimensión de 290953 valores, como podemos apreciar en el siguiente output de R:

```{r,echo=TRUE,eval=TRUE}
length(vuelos_reduc$YEAR)
```

 

******   
<h1><span style="color:darkblue"> **2. Integración y selección de los datos de interés a analizar**</span></h1>  
******   
Vamos a cargar los datos de localización de los aeropuertos y haremos un merge de los datos de los aeropuertos con el dataset que tenemos para, entre otras cosas, hacer una visualización en un mapa.  
Renombramos las columnas para dejar la misma nomenclatura en aquellas que queremos unir

```{r,echo=TRUE,eval=TRUE}
airports <- read.csv("datasets_810_1496_airports.csv", header=TRUE)
head(airports)
colnames(vuelos_reduc)[8]  <- "ORIGIN_CODE"
colnames(airports) <- c("ORIGIN_CODE","ORIGIN_AIRPORT", "ORIGIN_CITY", "ORIGIN_STATE", "ORIGIN_COUNTRY", "ORIGIN_LATITUDE", "ORIGIN_LONGITUDE" )

flight_airports <- left_join(vuelos_reduc,airports,by="ORIGIN_CODE")
```

Nos da error, porque como nuestro dataset es un subconjunto de los datos iniciales, puede que no estén todos los aeropuertos, por lo que tenemos que igualar los niveles de los dos campos tipo factor.
```{r,echo=TRUE,eval=TRUE}

combined <- sort(union(levels(vuelos_reduc$ORIGIN_CODE), levels(airports$ORIGIN_CODE)))
flight_airports <- left_join(mutate(vuelos_reduc, ORIGIN_CODE=factor(ORIGIN_CODE, levels=combined)),
                             mutate(airports, ORIGIN_CODE=factor(ORIGIN_CODE, levels=combined)))

#visualización del volumen de vuelos de cada aeropuerto
longitude <- unique(flight_airports$ORIGIN_LONGITUDE)
latitude <- unique(flight_airports$ORIGIN_LATITUDE)
df = data.frame(Lat = latitude, Long = longitude)
leaflet(df) %>% addTiles() %>% addCircleMarkers() #map visualization


```
  
En el mapa podemos visualizar donde están localizados los aeropuertos analizados en este dataset.
A continuación, lo que haremos será mostrar un gráfico de barras donde veremos el volumen de vuelos por cada aeropuerto. Debemos tener en cuenta que estamos trabajando con un conjunto reducido de los datos, por lo que este gráfico no nos aporta la información real del número de vuelos pero sí nos sirve para ver qué aeropuertos tienen mayor volumen de tráfico aereo.  


```{r}
popular_airports <- sort(table(flight_airports$ORIGIN_CODE), decreasing = TRUE )
barplot(popular_airports[1:10], col = "blue", ylim = c(0,20000))
```
  
También vemos que el jueves es el día de la semana con mayor número de vuelos. Al igual que antes, estamos trabajando con el conjunto de datos reducido, por lo que la información mostrada nos ayuda a ver el día de la semana con mayor número de vuelos pero el número que obtenemos no representa al total del año 2015, si no a nuestra muestra reducida.  

```{r}
sort(table(flight_airports$DAY_OF_WEEK), decreasing = TRUE )
```  
  
A partir de aquí, vamos a identificar los tipos de variables y a quedarnos con los datos que nos interesarán para realizar nuestro estudio.  
```{r,echo=TRUE,eval=TRUE}
res <- sapply(vuelos_reduc,class)
kable(data.frame(variables=names(res),clase=as.vector(res)), 
      caption = "asignación de clase de objeto R a cada variable")
```
  
Vemos la asignación de clase que R le da a cada variable. Sin embargo, tenemos que reasignarle la clase a algunas variables como vemos a continuación.  

```{r,echo=TRUE,eval=TRUE}
vuelos[1:4] <- lapply(vuelos[1:4], as.numeric)
vuelos[6] <- lapply(vuelos[6], as.numeric)
vuelos[10:25] <- lapply(vuelos[10:25], as.numeric)
vuelos[27:31] <- lapply(vuelos[27:31], as.numeric)
res <- sapply(vuelos,class)
tabla_datos <- data.frame(variables=names(res),clase=as.vector(res))
kable(tabla_datos, 
      caption = "asignación de clase de objeto R a cada variable")
```
  
Volvemos a ver un resumen con los primeros datos de cada variable:  
```{r,echo=TRUE,eval=TRUE}
str(vuelos)
```
  
De todas las variables cargadas, de momento nos vamos a quedar con las siguientes:  
*MONTH  
*DAY  
*DAY_OF_WEEK    
*AIRLINE   
*ORIGIN_CODE    
*DESTINATION_AIRPORT    
*SCHEDULED_DEPARTURE    
*DEPARTURE_TIME   
*DEPARTURE_DELAY    
*SCHEDULED_TIME    
*ELAPSED_TIME   
*AIR_TIME   
*DISTANCE   
*SCHEDULED_ARRIVAL   
*ARRIVAL_TIME     
*ARRIVAL_DELAY   
  

```{r,echo=TRUE,eval=TRUE}

vuelos_reduc <- dplyr::select(vuelos_reduc, -"YEAR",-"TAIL_NUMBER",-"AIR_SYSTEM_DELAY",-"SECURITY_DELAY",
                              -"AIRLINE_DELAY",-"LATE_AIRCRAFT_DELAY",-"WEATHER_DELAY",
                              -"TAXI_OUT",-"TAXI_IN",-"WHEELS_OFF", -"WHEELS_ON",-"DIVERTED",
                              -"CANCELLED",-"CANCELLATION_REASON")

str(vuelos_reduc)



```



******   
<h1><span style="color:darkblue"> **3. Limpieza de los datos**</span></h1>  
******   

<h2><span style="color:blue"> 3.1 Elementos vacíos</span></h2>

**¿Los datos contienen ceros o elementos vacíos? ¿Cómo gestionarías cada uno de estos casos?**  
  
En este apartado, vamos a comprobar los valores que contienen nuestras variables para detectar si hay errores en los mismo, si tenemos elementos vacios o ceros o si hay datos fuera de los valores esperados, por ejemplo en las horas, días o meses.


```{r,echo=TRUE,eval=TRUE}
#Comprobamos valore nulos o valores perdidos
sapply(vuelos_reduc, function(x) sum(is.na(x)))
#Otra forma de sacar los valores nulos
colSums(is.na(vuelos_reduc))
```

  
De los valores nulos que hemos identificado, hacemos una revisión para conocer el motivo de esos valores. Comprobamos que en el caso de los valores nulos en las variables DEPARTURE_DELAY y ARRIVAL_DELAY, se trata de aquellos vuelos que han sido cancelados o desviados, por lo que, como nuestro estudio va a estar basado en los vuelos completados, eliminaremos todos estos valores nulos.  
  
Comprobamos los valores nulos de la columna DEPARTURE_DELAY y ARRIVAL_DELAY:
```{r,echo=TRUE,eval=TRUE}
head(vuelos %>% filter(is.na(vuelos$DEPARTURE_DELAY)))

head(vuelos %>% filter(is.na(vuelos$ARRIVAL_DELAY)))
```
  

De momento como lo que queremos es trabajar con los vuelos retrasados vamos a eliminar los valores nulos de  estas variables
```{r,echo=TRUE,eval=TRUE}
vuelos_reduc <- vuelos_reduc[!is.na(vuelos_reduc$DEPARTURE_DELAY),]
vuelos_reduc <- vuelos_reduc[!is.na(vuelos_reduc$ARRIVAL_DELAY),]
```
  
Comprobamos que ya no quedan valores nulos:
```{r,echo=TRUE,eval=TRUE}

colSums(is.na(vuelos_reduc))
summary(vuelos_reduc)
```
  
Comprobamos los datos de meses y días, por ver que no hay valores extraños. También revisaremos que no hay distancias ni tiempos horarios negativos.

```{r,echo=TRUE,eval=TRUE}
#Comprobamos si hay valores extraños en las variables día, día de la semana y mes
month_wrong <- which(vuelos_reduc$MONTH > 12 | vuelos_reduc$MONTH < 1)
month_wrong

day_wrong <- which(vuelos_reduc$DAY > 31 | vuelos_reduc$DAY < 1)
day_wrong

day_week_wrong <- which(vuelos_reduc$DAY_OF_WEEK > 7 | vuelos_reduc$DAY_OF_WEEK <1)
day_week_wrong

```
  
Comprobamos que los valores de distancias y horas en base a los valores mínimos y máximos son correctos. En el caso de los aeropuertos, conocemos que hay aeropuertos que tienen diferente nomenclatura para un mismo aeropuerto, de momento no vamos a realizar ninguna modificación sobre este dato, supondremos que son aeropuertos diferentes.



<h2><span style="color:blue"> 3.2 Identificación y tratamiento de valores extremos</span></h2>
  
Vamos a identificar los posibles valores extermos que tenemos en las variables de tiempo y distancia. En base a los resultados decidiremos que acciones tomar con estas variables.

Para ello vamos representar las variables con un diagrama de cajas y bigotes que nos mostrará visualmente dichas variables a través de sus cuartiles.

Las lineas que salen de las cajas se conocen como "bigotes" e indican la variabilidad fuera de los cuartiles superior e inferior. Los valores extremos (outliers) se representarán como puntos individuales. Dentro de la caja, la línea que vemos nos muestra la mediana.


```{r,echo=TRUE,eval=TRUE}
boxplot(vuelos_reduc$DEPARTURE_DELAY, main="DEPARTURE_DELAY") 
head(vuelos_reduc$DEPARTURE_DELAY)
head(boxplot.stats(vuelos_reduc$DEPARTURE_DELAY)$out)
```
  
En el diagrama de cajas para la variable DEPARTURE_DELAY podemos apreciar como la mayoría de los vuelos no se retrasan y por eso la caja y los bigotes toman valores de 0 (aprox). Por este motivo, todos los retrasos se consideran valores outliers y, dado que el propósito de esta variable es mostrar los retrasos en las salidas, no podemos eliminar estos valores ya que son los que le dan sentido a la variable. Por otro lado, observamos el amplio rango de valores outliers (retrasos) que hay, llegando a superar valores de 1500 minutos, aunque sí que es cierto que la mayoría se concentran entre los valores de <0 a 1000 minutos.

En las tablas podemos observar con más detalle los cinco primeros valores que toma esta variable y, comprobamos la disparidad de los retrasos.

Los valores negativos nos indican que los vuelos salieron antes de su hora programada en un primer momento.


```{r,echo=TRUE,eval=TRUE}
boxplot(vuelos_reduc$SCHEDULED_TIME, main="SCHEDULED_TIME") 
head(vuelos_reduc$SCHEDULED_TIME)
```
  
En el caso de la variable SCHEDULED_TIME (tiempo programado de vuelo) sí podemos apreciar mejor la caja y los bigotes del diagrama.
Vemos que todos los valores extremos se encuentran por encima del extremo superior por lo que todos nos indican que el tiempo programado de vuelo ha sido excedido.
Al igual que ocurría con la variable anteriormente analizada, de esta variable nos interesan todos sus valores por lo que no podemos eliminar sus valores extremos ya que estaríamos desperdiciando información importante.

En las tablas vemos con más detalles sus valores. 

```{r,echo=TRUE,eval=TRUE}
boxplot(vuelos_reduc$AIR_TIME, main="AIR_TIME") 
head(vuelos_reduc$AIR_TIME)
```
  
Para la vairable AIR_TIME (tiempo desde el despegue hasta el aterrizaje) vemos que la mayoría de vuelos duran entre 50 y 150 minutos aproximadamente, llegando el extremo superior a prácticamente 300 minutos. A partir de este valor nos encontramos con los datos extremos llegando hasta prácticamente los 700 minutos en su valor máximo.
Dado que los valores extremos representan valores reales de duraciones de vuelo no nos interesa quitar dichos valores de la muestra ya que no se deben a posibles errores y nos aportan información valiosa.
En la tabla vemos de manera más detallada la información de dicha variable. 

```{r,echo=TRUE,eval=TRUE}
boxplot(vuelos_reduc$DISTANCE, main="DISTANCE") 
head(boxplot.stats(vuelos_reduc$DISTANCE)$out)
```
  
Para la varialbe DISTANCE (distancia en millas) observamos que la mayor parte de los vuelos transcurren en distancias de hasta 1000 millas aproximadamente, llegando el extremo superior a las 2000 millas aproximadamente. A partir de las 2000 millas nos encontramos los valores outliers, concentrandose la mayor parte de ellos hasta las 3000 millas. Vuelos de entre 3000 millas hasta 5000 millas nos encontramos muy pocos como observamos tanto en el diagrama como en la tabla. 

```{r,echo=TRUE,eval=TRUE}
boxplot(vuelos_reduc$ARRIVAL_DELAY, main="ARRIVAL_DELAY") 
head(vuelos_reduc$ARRIVAL_DELAY)
```
  
Como era de esperar, el análisis de la variable ARRIVAL_DELAY (diferencia en minutos entre la llegada programada y la real) es muy similar al que vimos en la primera variable analizada (DEPARTURE_DELAY). 
Como ya explicamos anterioremente, la mayoría de los vuelos no sufren retrasos por lo que tanto la caja como los bigotes toman valores cercanos a 0. A partir de ahí, todos los valores ouliers que podemos observar nos muestran los retrasos en la llegada de los vuelos (vemos que el vuelo con mayor retraso superó los 1500 minutos).
No podemos eliminar dichos valores ya que son la esencia de esta variable.

 
  
En resumen, el conjunto de datos que estamos tratando tiene muchos valores muy dispersos, de momento no vamos a hacer nada con ellos, los mantendremos y en algunos casos concretos, si fuese necesario, realizaremos los filtrados correspondientes.


******   
<h1><span style="color:darkblue"> **4. Análisis de los datos**  </span></h1>  
******   
  
<h2><span style="color:blue"> 4.1 Selección de los grupos de datos  </span></h2>

**Selección de los grupos de datos que se quieren analizar/comparar (planificación de los análisis a aplicar)**  
Para poder trabajar mejor con las variables de tiempo, y dado que no nos van a interesar en principio los minutos vamos a dejar solamente las horas para poder realizar ciertos análisis de este dato.

```{r,echo=TRUE,eval=TRUE}

vuelos_reduc$SCHEDULED_DEPARTURE_HOUR=format(round(trunc(vuelos_reduc$SCHEDULED_DEPARTURE/100),digits=0), nsmall=0)
vuelos_reduc$SCHEDULED_DEPARTURE_HOUR <- as.numeric(vuelos_reduc$SCHEDULED_DEPARTURE_HOUR)
head(vuelos_reduc$SCHEDULED_DEPARTURE_HOUR)

table(vuelos_reduc$SCHEDULED_DEPARTURE_HOUR)

vuelos_reduc$DEPARTURE_HOUR=format(round(trunc(vuelos_reduc$DEPARTURE_TIME/100),digits=0), nsmall=0)
vuelos_reduc$DEPARTURE_HOUR <- as.factor(vuelos_reduc$DEPARTURE_HOUR)
head(vuelos_reduc$DEPARTURE_HOUR)

table(vuelos_reduc$DEPARTURE_HOUR)

vuelos_reduc$ARRIVAL_HOUR=format(round(trunc(vuelos_reduc$ARRIVAL_TIME/100),digits=0), nsmall=0)
vuelos_reduc$ARRIVAL_HOUR <- as.factor(vuelos_reduc$ARRIVAL_HOUR)
head(vuelos_reduc$ARRIVAL_HOUR)

table(vuelos_reduc$ARRIVAL_HOUR)%>% knitr::kable("html")  %>% kable_styling(position='center', font_size=12, fixed_thead=list(enabled=T))
```
  
Creamos una nueva variables que identifique el retraso total, en base a la perdida o ganancia en el tiempo de llegada frente al tiempo de adelanto o retraso en la salida
```{r,echo=TRUE,eval=TRUE}

vuelos_reduc <- mutate(vuelos_reduc, RETRASO_TOTAL=ARRIVAL_DELAY - DEPARTURE_DELAY) 

str(vuelos_reduc)
boxplot(vuelos_reduc$RETRASO_TOTAL , xlab="Retrasos", ylab="minutos", ylim=c(-100, 400) )
table(boxplot.stats(vuelos_reduc$RETRASO_TOTAL)$out)
hist(vuelos_reduc$RETRASO_TOTAL)

vuelos_reduc %>% 
  ggplot( aes(x=RETRASO_TOTAL)) +
  geom_density(fill="#99A3A4", color="#99A3A4", alpha=0.9)
```
  
En los gráficos podemos ver como, del mismo modo que se tenía en el gráfico de cajas y bigotes del apartado 3 para las variables DEPARTURE_DELAY y ARRIVAL_DELAY, para esta nueva variable, se tiene un comportamiento similar, como era de esperar. La gran mayoría de los vuelos se concentran alrededor del 0, es decir que los vuelos salen y llegan en los tiempos establecidos. Sin embargo el gráfico se alarga a ambos lados, sobre todo hacia la derecha, debido a la gran dispersión de tiempos de vuelos retrasados (diferencia positiva).


<h2><span style="color:blue"> 4.2 Comprobación de la normalidad y homogeneidad de la varianza</span></h2>  
  
Utilizaremos la prueba Shapiro-Wilk test para comprobar la normalidad de la muestra para los valores DEPARTURE_DELAY, ARRIVAL_DELAY y DISTANCE
```{r,echo=TRUE,eval=TRUE}

shapiro.test(vuelos_reduc$DEPARTURE_DELAY[1:5000])

shapiro.test(vuelos_reduc$ARRIVAL_DELAY[1:5000])

shapiro.test(vuelos_reduc$DISTANCE[1:5000])
shapiro.test(vuelos_reduc$RETRASO_TOTAL[1:5000])
```
  
La prueba de Saphiro-Wilk, solo es posible para un máximo de 5000 registros, por lo que hemos realizado la prueba con un subconjunto con esa cantidad, y nos da como resultado que debemos rechazar la hipótesis nula, es decir, nos indicaría que las variables no siguen una distribución normal. Sin embargo, por el teorema central del límite, la distribución de la media de  cualquier muestra de datos se considera cada vez más normal según aumenta el tamaño de la misma y para  muestras superiores con N>30 se puede suponer normalidad, dado que podría aproximarse a una disribución normal.  

```{r,echo=TRUE,eval=TRUE}

hist(vuelos_reduc$RETRASO_TOTAL)


```

Aparentemenete, para esta variable, según el gráfico podríamos decir que la variable sigue una distribución normal.  
Vamos a intentar generar Q-QPlot para mostrar gráficamente si la muestra sigue una distribución normal.  
```{r,echo=TRUE,eval=TRUE}
par(mfrow=c(2,1))
qqnorm(vuelos_reduc$RETRASO_TOTAL, pch = 1, frame = FALSE)
qqline(vuelos_reduc$RETRASO_TOTAL, col = "steelblue", lwd = 2)
boxplot(vuelos_reduc$RETRASO_TOTAL, horizontal=T)
```
  
Contrastamos el gráfico Q-QPlot contra el gráfico de cajas, para ver el comportamiento. En el gráfico de arriba, podemos ver que los valores de la variable no se pegan a la recta, de hecho, se levanta hacia la parte de la derecha despegándose de la recta y solo unos cuantos valores centrales se tienen alrededor de la recta. Esto nos está identificando que esta variable tiene una gran cantidad de valores extremos que hacen que tengamos que preguntarnos si la variable sigue una distribución normal.
  
Como no tenemos seguridad de si la población que estamos estudiando sigue una distribución normal, utilizaremos el test de Levene para comprobar la homogeneidad de la varianza u homocedasticidad. Compararemos nuestra variable con la variable DAY_OF_WEEK (realizamos una agrupación de los datos por día de la semana). Tomaremos como hipótesis nula la semajanza de variables y como hipótesis alternativa la no igualdad en la varianza de las varibales con un índice de significación ${\alpha}$=0.05
```{r,echo=TRUE,eval=TRUE}
str(vuelos_reduc)

plot(RETRASO_TOTAL ~ as.factor(DAY_OF_WEEK), data=vuelos_reduc)
```
  
Según el gráfico parece que podemos tener homogeneidad en las varianzas

```{r,echo=TRUE,eval=TRUE}
LeveneTest(RETRASO_TOTAL ~ as.factor(DAY_OF_WEEK), vuelos_reduc, center=median)
```
  
El Test de Levene nos da un p-valor de 1.099e-06 que es menor que 0.05 (95% de nivel de significación), con lo que rechazaríamos la hipotesis nula de varianzas iguales.  

Comprobamos con el test de Filgner-Killeen, que habitualmente se utiliza si desconocemos si la distribución es normal o en el caso de que no se tenga una distribución normal de la varible.
```{r,echo=TRUE,eval=TRUE}
fligner.test(RETRASO_TOTAL ~ as.factor(DAY_OF_WEEK), data=vuelos_reduc)
```
  
Comprobamos que para este caso, el resultado sigue siendo un p-valor por debajo de 0.05, por lo que también rechazaríamos la hipótesis nula. Es decir, parece que se tienen diferencias significativas entre las varianzas de ambos grupos.

Comprobamos con otras variables como el mes o la hora de salida.

```{r,echo=TRUE,eval=TRUE}
plot(RETRASO_TOTAL ~ as.factor(MONTH), data=vuelos_reduc)
LeveneTest(RETRASO_TOTAL ~ as.factor(MONTH), vuelos_reduc, center=mean)

plot(RETRASO_TOTAL ~ DEPARTURE_HOUR, data=vuelos_reduc)
```
  
En el caso de la hora de salida si que se aprecian ciertas diferencias los tramos horarios de madrugada, donde no hay apenas vuelos programados, por lo que el resultado esperado en este caso podría decirse que será la no homogeneidad de la varianza.

```{r,echo=TRUE,eval=TRUE}
LeveneTest(RETRASO_TOTAL ~ DEPARTURE_HOUR, vuelos_reduc, center=mean)

```
  
Comprobamos que el p-valor obtenido, como en los casos anteriores, nos hace rechazar la hipótesis nula de varianzas similares. Por lo que se determina que no hay homogeneidad en las variables.

Vemos si podemos conseguir una mejora de la normalidad y la homocedasticidad aplicando la transformación de Box-Cox
```{r,echo=TRUE,eval=TRUE}


bx_vuelos_reduc <- BoxCox(vuelos_reduc$RETRASO_TOTAL, lambda = BoxCoxLambda(vuelos_reduc$RETRASO_TOTAL))


par(mfrow=c(2,2))
qqnorm(vuelos_reduc$RETRASO_TOTAL, main="Lognormal")
qqline(vuelos_reduc$RETRASO_TOTAL,col=2)
qqnorm(bx_vuelos_reduc, main="Box-Cox")
qqline(bx_vuelos_reduc,col=2)
hist(vuelos_reduc$RETRASO_TOTAL,main="Lognormal")
hist(bx_vuelos_reduc, main="Box-Cox")
```
  
No parece que encontremos una mejora de los datos con la transformación de Box-Cox. 




<h2><span style="color:blue"> 4.3 Aplicación de pruebas estadísticas</span>></h2>  

**Aplicación de pruebas estadísticas para comparar los grupos de datos. En función de los datos y el objetivo del estudio, aplicar pruebas de contraste de hipótesis, correlaciones, regresiones, etc. Aplicar al menos tres métodos de análisis diferentes.**  

  
Lo primero que vamos a hacer es comprobar la correlación entre algunas de las variables:
```{r,echo=TRUE,eval=TRUE}
correlacion <- dplyr::select(vuelos_reduc, "SCHEDULED_DEPARTURE", "DEPARTURE_TIME", "DEPARTURE_DELAY", 
                      "AIR_TIME", "DISTANCE", "SCHEDULED_ARRIVAL", "ARRIVAL_TIME","ARRIVAL_DELAY",
                      "RETRASO_TOTAL","DAY_OF_WEEK","MONTH")

corr.res<-cor(correlacion)
corrplot(corr.res,method="circle")
```
  
Comprobamos una fuerte relación entre el retraso en la salida y el retraso en la llegada, que puee deberse a los vuelos no retrasados o quizá pueda ser, que al contrario de lo que podríamos pensar, el retraso en la salida no es recuperado en la llegada.  
También vemos una fuerte relación entre la distancia y el tiempo de vuelo, algo que era de esperar. Se tiene también una relación, aunque no tan fuerte entre el tiempo estimado de llegada y el tiempo real de llegada.
  
Nos preguntamos ahora por la relación entre el retraso/adelanto de un vuelo con la hora del día en la que se realiza Para ello usaremos un modelo de regresión, dado que la variable día de la semana es de tipo factor y además crearemos una nueva variable que nos indique si el vuelo se ha retrasado o no.  
Primero vamos a crear la tabla de contingencia y calcularemos la estimación Odds Ratio para ver la relación entre las variables Veremos si existe relación entre la variable dependiente, en nuestro caso si hay retraso o no y las variables explicativas.  
Dividimos la muestra:  
```{r,echo=TRUE,eval=TRUE}
retraso <- data.frame (RETRASO=vuelos_reduc$RETRASO_TOTAL)
retraso$RETRASO <- ifelse (retraso$RETRASO>0, "SI", "NO")
retraso <- data.frame (retraso, WEEKEND=vuelos_reduc$DAY_OF_WEEK)
#Contamos como fin de semana los viernes, sábados y domingos
retraso$WEEKEND <- ifelse ((retraso$WEEKEND=="5" | retraso$WEEKEND=="6" | retraso$WEEKEND=="7"), "WEEKEND", "WEEKDAY")
str(retraso)
table (retraso$RETRASO)

tabla_retraso_dias <- with(retraso, table(retraso$RETRASO,retraso$WEEKEND))
tabla_retraso_dias %>% knitr::kable("html")  %>% kable_styling(position='center', font_size=12, fixed_thead=list(enabled=T))
```
  
Aplicamos la función chi-cuadrado de Pearson a las variables para conocer si podemos aceptar la hipótesis nula y por lo tanto las variables no están relacionadas.
```{r,echo=TRUE,eval=TRUE}
chisq.test(tabla_retraso_dias, correct=FALSE)
```
  
El p-value encontrado con el test chi-cuadrado es p-value < 2.2e-16 que se encuentra muy por debajo del nivel de significación marcado de 0.05, por lo que rechazamos la hipótesis nula y por lo tanto podemos concluir en  este caso que existe relación entre retraso y el día de la semana.  
```{r,echo=TRUE,eval=TRUE}
library(epitools)
oddsratio(tabla_retraso_dias, verbose = TRUE)
oddsratio(tabla_retraso_dias, rev="columns", verbose = TRUE)
```
  
El Odds Ratio nos indica que la razón entre la ocurrencia de retraso del vuelo frente a no retraso es 0,93 veces mayor en día laborable y de 1.068 veces superior en fin de semana. Identificamos que no es una diferencia muy pronunciada.  
  
Realizamos el modelo de regresión lineal simple en el que estudiaremos la relación entre el retraso del vuelo en la llegada junto con la hora establecida 
```{r,echo=TRUE,eval=TRUE}
ggplot(vuelos_reduc, aes(x=SCHEDULED_ARRIVAL, y=ARRIVAL_DELAY)) +
  geom_point() +
  geom_smooth(method=lm , color="red", se=FALSE)


retraso_modelo1 <- lm(ARRIVAL_DELAY~SCHEDULED_ARRIVAL, vuelos_reduc)
retraso_modelo1 
summary(retraso_modelo1)
```
  
No conseguimos un buen modelo, seguramente porque no tenemos una dependencia lineal entre los valores.  

Probamos a incluir en el modelo la variable distancia
```{r,echo=TRUE,eval=TRUE}

retraso_modelo2 <- lm(ARRIVAL_DELAY~SCHEDULED_ARRIVAL + DISTANCE, vuelos_reduc)
retraso_modelo2 
summary(retraso_modelo2)

retraso_modelo3 <- lm(ARRIVAL_DELAY~SCHEDULED_DEPARTURE + DISTANCE + SCHEDULED_ARRIVAL, vuelos_reduc)
retraso_modelo3 
summary(retraso_modelo3)

#y=-4.216+0.006x1+0.0013x2+0.003x3
```
*Revisar* Estos factores no tienen impacto o no están relacionados con el retraso.
  
Modelos de regresión logística:  
Utilizaremos el dataframe creada anteriormente para incluir las variables en el formato correcto para la regresión. ¿Está el retraso asociado a los vuelos de fin de semana y a la hora de salida?
```{r,echo=TRUE,eval=TRUE}
retraso1 <- data.frame(retraso, DEPARTURE_HOUR=vuelos_reduc$DEPARTURE_HOUR)
retraso$WEEKEND <- ifelse(retraso1$RETRASO=="NO", 0, 1)
retraso1[1:2] <- lapply(retraso1[1:2], as.factor)
str(retraso1)

retraso_glm1 <- glm(RETRASO~WEEKEND , data=retraso1, family=binomial(logit))
retraso_glm1

summary(retraso_glm1)

retraso2 <- data.frame(retraso1, DISTANCE=vuelos_reduc$DISTANCE)
str(retraso2)
retraso_glm2 <- glm(RETRASO~DEPARTURE_HOUR + DISTANCE, data=retraso2, family=binomial(logit))
retraso_glm2
summary(retraso_glm2)
```
  
El modelo anterior no es para nada bueno, no parece que se relacionen, como ya se había visto en el gráfico de correlación. Vamos a intentar crear el modelo teniendo como variables explicativas la distancia y la hora de salida del vuelo por ver si puede haber una posible realción

```{r,echo=TRUE,eval=TRUE}
retraso3 <- data.frame(retraso2, MONTH=vuelos_reduc$MONTH,
                      SCHEDULED_DEPARTURE=vuelos_reduc$SCHEDULED_DEPARTURE)
str(retraso3)
retraso_glm3 <- glm(RETRASO~SCHEDULED_DEPARTURE + DISTANCE + MONTH, data=retraso3, family=binomial)
retraso_glm3
summary(retraso_glm3)
```
  
Vamos a realizar una predicción de retraso con el modelo que hemos creado, para el caso de un vuelo que salga a las 8horas y  que tenga una distancia de 1000 milas en el mes de junio y otro que salga a las 19 horas
```{r,echo=TRUE,eval=TRUE}
newdata = data.frame(SCHEDULED_DEPARTURE = 0800 , DISTANCE=1000, MONTH=6)
predict(retraso_glm3, newdata , type="response")

newdata2 = data.frame(SCHEDULED_DEPARTURE =1600, DISTANCE=1000, MONTH=6)
predict(retraso_glm3, newdata2 , type="response")
```
  
La probabilidad de retraso en el primer caso será de 0.27 veces superior que no sufrir retraso. En el caso de que el vuelo tenga su salida a las 16 horas será de 0.26 veces más.
  
Incluimos ahora en el modelo el atributo de Aeropuerto de salida.
  
```{r,echo=TRUE,eval=TRUE}
retraso4 <- data.frame(retraso3, ORIGIN_AIRPORT=vuelos_reduc$ORIGIN_CODE)
```

PAra este modelo, nos Vamos a centrar únicamente en los 10 aeropuertos con más tráfico.
```{r,echo=TRUE,eval=TRUE}
# Para que los resultados estén acotados, elegimos los 10 aeropuertos con más tráfico:
retraso$ORIGIN_AIRPORT <- ifelse (retraso4$ORIGIN_AIRPORT %in% 
                            c("ATL","ORD","DFW","DEN","LAX","SFO","PHX","IAH","LAS","MSP"),
                            retraso4$ORIGIN_AIRPORT,
                            "OTROS")
str(retraso4)
#retraso_glm4 <- glm(RETRASO~DEPARTURE_HOUR + DISTANCE + MONTH + ORIGIN_AIRPORT, data=retraso4,
#                    family=binomial)
#retraso_glm4
#summary(retraso_glm4)

```
  
Vamos a realizar un contraste de hipótesis, nos preguntamos si la proporción de vuelos retrasados es inferior a la de vuelos en los tiempos establecidos.Para ello realizaremos un contraste sobre la proporción para muestras grandes.  
Consideramos que tenemos una población que toma el valor 1 cuando el vuelo está retrasado y el 0 cuando no lo está. Tenemos por tanto una distribución de Bernoulli con parámetro *p* desconocido.
$p_0$ será un valor prefijado, en nuestro caso 0.5, es decir el 50% que marcaría la igualdad de proporción de vuelos retrasados y no retrasados. 
$$
\left\{
\begin{array}{ll}
Hipótesis\ Nula & H_{0}: & p = p_0\\
Hipótesis\ Alternativa & H_{1}: & p < p_0
\end{array}
\right.
$$
   
Separamos las muestras de los vuelos retrasados RETRASO_TOTAL>0 y los no retrasados RETRASO_TOTAL<=0
```{r,echo=TRUE,eval=TRUE}
head(vuelos_reduc)
vuelos_reduc$DELAYED <- ifelse(vuelos_reduc$RETRASO_TOTAL>0, 1, 0)

vuelos_reduc %>% 
  group_by(DELAYED) %>%
  summarize(num_obs = n(), 
            mean_delayed = round(mean(RETRASO_TOTAL),0),
            sd_delayed = round(sd(RETRASO_TOTAL),0))

DELAYED_GROUPED <- vuelos_reduc %>% group_by(DELAYED) %>% summarize(num_obs = n(), 
                                                                    obs_totales =length(vuelos_reduc$DAY), 
                                                                    p = num_obs/obs_totales)
DELAYED_GROUPED %>% knitr::kable("html")  %>% kable_styling(position='center', font_size=12, fixed_thead=list(enabled=T))

n1=DELAYED_GROUPED[1,2]
n2=DELAYED_GROUPED[2,2]

prop.test(x=c(209810,75840), n=c(285650,285650), p=NULL, alternative="less", correct=TRUE)


```





*Aplicamos ahora el algoritmo random forest para conocer el aeropuerto que debemos evitar*
Predecir si un vuelo va a retrasarse en función del mes, día, hora y aeropuerto.  

```{r,echo=TRUE,eval=TRUE}
str(retraso4)
#Seleccionamos solo las variables que vamos a utilizar para aplicar el modelo. Dejaremos fuera SCHEDULED_DEPARTURE.
retraso_rf <- select (retraso4, -"SCHEDULED_DEPARTURE")
```
  
Para poder crear el modelo, factorizamos la variable distancia, creando rangos de 1000 Millas.  
```{r,echo=TRUE,eval=TRUE}
RANGO_DISTANCIA <- vector()
RANGO_DISTANCIA[retraso_rf$DISTANCE<=500] <- 1
RANGO_DISTANCIA[retraso_rf$DISTANCE>500 & retraso_rf$DISTANCE<=1000] <- 2
RANGO_DISTANCIA[retraso_rf$DISTANCE>1000 & retraso_rf$DISTANCE<=1500] <- 3
RANGO_DISTANCIA[retraso_rf$DISTANCE>1500 & retraso_rf$DISTANCE<=2000] <- 4
RANGO_DISTANCIA[retraso_rf$DISTANCE>2000 & retraso_rf$DISTANCE<=2500] <- 5
RANGO_DISTANCIA[retraso_rf$DISTANCE>2500 & retraso_rf$DISTANCE<=3000] <- 6
RANGO_DISTANCIA[retraso_rf$DISTANCE>3000] <- 7

retraso_rf$RANGO_DISTANCIA <- as.factor(RANGO_DISTANCIA)

levels(retraso_rf$RANGO_DISTANCIA) <- c("Menor 500","Entre 500 y 1000","Entre 1000 y 1500",
                                        "Entre 1500 y 2000","Entre 2000 y 2500","Entre 2500 y 3000",
                                        "Mayor 3000")
table(retraso_rf$RANGO_DISTANCIA)

retraso_rf <- select (retraso_rf, -"DISTANCE")

retraso_rf$MONTH <- as.factor(retraso_rf$MONTH)
```
  
Factorizamos también la variable aeropuerto origen para incluirla a posteriori en el modelo.

```{r,echo=TRUE,eval=TRUE}
retraso_rf$ORIGIN_AIRPORT <- ifelse (retraso_rf$ORIGIN_AIRPORT %in% 
                            c("ATL","ORD","DFW","DEN","LAX","SFO","PHX","IAH","LAS","MSP"),
                            retraso_rf$ORIGIN_AIRPORT,
                            "OTROS")
retraso_rf$ORIGIN_AIRPORT <- as.factor(retraso_rf$ORIGIN_AIRPORT)
head(retraso_rf)

```
  
Contrastamos algunos de los atributos con la variable retraso:  
```{r,echo=TRUE,eval=TRUE}
grid.newpage()
plotbyweekend<-ggplot(retraso_rf,aes(WEEKEND,fill=RETRASO))+geom_bar() +labs(x="WEEKEND", y="RETRASO")+ guides(fill=guide_legend(title=""))+ scale_fill_manual(values=c("black","#008000"))+ggtitle("RETRASO POR DÍA DE LA SEMANA")
plotbydistance<-ggplot(retraso_rf,aes(RANGO_DISTANCIA,fill=RETRASO))+geom_bar() +labs(x="RANGO_DISTANCIA", y="RETRASO")+ guides(fill=guide_legend(title=""))+ scale_fill_manual(values=c("black","#008000"))+ggtitle("Retraso por Distancia")
plotbyMeses<-ggplot(retraso_rf,aes(MONTH,fill=RETRASO))+geom_bar() +labs(x="MONTH", y="RETRASO")+ guides(fill=guide_legend(title=""))+ scale_fill_manual(values=c("black","#008000"))+ggtitle("Retraso por Mes")
plotbySalida<-ggplot(retraso_rf,aes(DEPARTURE_HOUR,fill=RETRASO))+geom_bar() +labs(x="DEPARTURE_HOUR", y="RETRASO")+ guides(fill=guide_legend(title=""))+ scale_fill_manual(values=c("black","#008000"))+ggtitle("Retraso por Hora Salida")

grid.arrange(plotbyweekend,plotbydistance,plotbyMeses,plotbySalida,ncol=2)
```
  

  
Dividimos el conjunto de datos en 2 conjuntos, uno que utilizaremos de entrenamiento y otro para test (70/30)  
Como variable de clasificación será "RETRASO" y la incluiremos en el valor de las "y", el resto de atributos se incluirán en el valor de "x"  
Comprobamos si tenemos que desordenar el data set para seleccionar el conjunto de entrenamiento.  
```{r,echo=TRUE,eval=TRUE}
head(retraso_rf,10)
```
  
No se encuentra ordenado por la variable de clasificación, así que no vamos a desordenar el conjunto.  

```{r,echo=TRUE,eval=TRUE}


set.seed(300)
indexes = sample(1:nrow(retraso_rf), size=floor((0.7)*nrow(retraso_rf)))
train <- retraso_rf[indexes,]
test <- retraso_rf[-indexes,]

str(train)
```
  
Creamos el modelo de árbol de decisión 

```{r,echo=TRUE,eval=TRUE}
#Creamos el modelo
model <- randomForest(RETRASO ~.,data=train, importance=T, ntree=300, mtry=4)
```
  
Comprobamos la importancia de las variables en el modelo.
```{r,echo=TRUE,eval=TRUE}
varImpPlot(model)

plot(model)
```
  
Vemos a continuación como funciona este modelo, generando hasta 300 posibles árboles de decisión con las disitntas variables.

```{r,echo=TRUE,eval=TRUE}
print(model)
```
  
Este modelo nos da una tasa de error del 27.87%, esta es la proporción de observaciones que no han sido bien clasificadas por el modelo. Comprobamos que la clasificación de vuelos retrasados no es buena. Comprobamos la matriz de confusión.

```{r,echo=TRUE,eval=TRUE}

mat_confusion<-table(train$RETRASO,model$predicted)
mat_confusion
```
  
Vamos a ver el porcentaje de registros clasificados correctamente.
```{r,echo=TRUE,eval=TRUE}
porcentaje_correct<-100 * sum(diag(mat_confusion)) / sum(mat_confusion)
print(sprintf("El %% de registros correctamente clasificados es: %.4f %%",porcentaje_correct))
```
  
Validamos el modelo con los datos de test.  
```{r,echo=TRUE,eval=TRUE}
resultado<- predict( model, test, type="class" )

confusionMatrix(model$predicted, train$RETRASO)
```
  
Realizamos la predicción sobre el resultado de test.
```{r,echo=TRUE,eval=TRUE}
confusionMatrix(resultado, test$RETRASO)
```
  
Obtenemos un grado de precisión muy similar sobre el conjunto de entrenamiento y sobre el conjunto de test. No es un modelo demasiado bueno, en ambos casos se encuentra alrededor del 70%.  
  



******   
<h1><span style="color:darkblue"> **5. Representación de los resultados**</span></h1>  
******   

**Representación de los resultados a partir de tablas y gráficas.**
  
En este apartado intentaremos dar respuesta a algunas de nuestras dudas mediante la representación gráfica de los datos elegidos.  
Comenzamos las representaciones viendo qué aeropuertos son los que mayor volumen de vuelos acogen:  
```{r,echo=TRUE,eval=TRUE}
#Comprobamos en un gráfico de barras los aeropuertos más populares.
popular_airports <- sort(table(vuelos_reduc$ORIGIN_CODE), decreasing = TRUE )
barplot(popular_airports[1:10], col = "blue", ylim = c(0,20000))
```
  
En la gráfica de barras podemos observar que fue el aeropuerto de Atlanta el más popular de Estados Unidos en el año 2015. En realidad, era de esperar este resultado, dado que el aeropuerto de Atlanta es el aeropuerto con más tráfico aéreo de Estados Unidos y del mundo.   

Una vez que tenemos el aeropuerto, ahora vamos a ver qué dia de la semana es en el que se producen más vuelos.
```{r,echo=TRUE,eval=TRUE}
#visualización del volumen de vuelos de cada día de la semana

dias_semana <- sort(table(vuelos_reduc$DAY_OF_WEEK), decreasing=TRUE)


barplot(dias_semana, col = "blue", ylim = c(0,50000))

ggplot(vuelos_reduc, aes(x=DAY_OF_WEEK, fill=DAY_OF_WEEK )) + 
  geom_bar( ) +
  scale_fill_hue(c = 40)
```
  
Se comprueba que el tráfico diario en los días laborables es muy similar, viendose un cambio de tendencia en el fin de semana, en concreto en el sábado.  
  
En el siguiente gráfico, veremos la relación del número de vuelos frente al mes del año:  

```{r,echo=TRUE,eval=TRUE}
ggplot(vuelos_reduc, aes(x=MONTH, fill=MONTH )) + 
  geom_bar( ) +
  scale_fill_hue(c = 20)
```
  
De este gráfico comprobamos que febrero es el mes que menos vuelos se producen (uno de los factores que pueden influir en este hecho es que es el mes del año más corto).  
Por otro lado vemos, que los meses de verano son los que mayor afluencia de vuelos hay, siendo julio el que alberga el mayor número de vuelos.  
  
Otra conclusión que podemos sacar, es que quitando los meses de verano, en el resto del año se aprecia la tencencia en el que los meses con 30 días tienen menor volumen de vuelos que los de 31 días.  

```{r,echo=TRUE,eval=TRUE}
ggplot(vuelos_reduc, aes(x=AIRLINE, fill=AIRLINE )) + 
  geom_bar( ) +
  scale_fill_hue(c = 40)
```
  
En el grafico que muestran el número de vuelos de cada aerolínea podemos ver como una de ellas prevalece sobre todas las demás.  
La aerolínea WN, cuyas siglas corresponden a Southwest Airlines Co. operó más de 60000 vuelos en el año 2015 en Estados Unidos, mientras que la segunda que le sigue en el ranking operó 45000 vuelos. Vemos que la diferencia es muy significativa. Southwest Airlines es la mayor compañía aeronáutica de Estados Unidos y el mayor operador de bajo coste del mundo.  

  
```{r,echo=TRUE,eval=TRUE}
vuelos_reduc %>% 
  filter( RETRASO_TOTAL>0) %>%
  ggplot(aes(AIRLINE,fill=RETRASO_TOTAL))+geom_bar() +labs(x="ORIGIN_CODE", y="RETRASO_TOTAL")+ guides(fill=guide_legend(title=""))+ scale_fill_manual(values=c("black","#008000"))+ggtitle("Retraso por Distancias")
```   
  
Si comprobamos el retraso por aerolínea, nos aparece Southwest como la aerolínea con más vuelos retrasados con bastante diferencia.  
  
```{r,echo=TRUE,eval=TRUE}
#Horas de salida de los vuelos
ggplot(vuelos_reduc, aes(x=DEPARTURE_HOUR, fill=DEPARTURE_HOUR )) + 
  geom_bar( ) +
  scale_fill_hue(c = 20) +
  theme(legend.position="none")
```
  
También queremos comprobar las horas del día con mayor número de vuelos y, como era de esperar la mayoría de los vuelos se producen de 6 de la mañana a 7 de la tarde. Cayendo significativamente a valores prácticamente nulos en la madrugada.  

```{r,echo=TRUE,eval=TRUE}
#Horas de llegada
ggplot(vuelos_reduc, aes(x=ARRIVAL_HOUR, fill=ARRIVAL_HOUR )) + 
  geom_bar( ) +
  scale_fill_hue(c = 20) +
  theme(legend.position="none")
```
  
Por otro lado, las horas de llegadas más populares fueron de 9 de la mañana a 9 de la noche. Vemos que hay un desplazamiento de horario de 2-3 horas con respecto a la gráfica de las horas de salida, lo cual es lógico si tenemos en cuenta la duración de los vuelos.

```{r,echo=TRUE,eval=TRUE}

hist(vuelos_reduc$ARRIVAL_DELAY,breaks = 1000, xlim = c(-100,150))

#Retraso por aerolínea
#Analizamos los vuelos retrasados cuando el retraso es menor de 200 minutos
vuelos_reduc %>% 
  filter( DEPARTURE_DELAY<200 & DEPARTURE_DELAY>0) %>%
  ggplot( aes(x=DEPARTURE_DELAY)) +
  geom_density(fill="#99A3A4", color="#99A3A4", alpha=0.9)

```

```{r,echo=TRUE,eval=TRUE}
vuelos_reduc %>% 
  filter( RETRASO_TOTAL>0) %>%
  ggplot( aes(x=AIRLINE)) +
  geom_density(fill="#99A3A4", color="#99A3A4", alpha=0.9)
```
  
Comprobamos que los resultados entre de los retrasos tanto de llegada como de salida por aerolínea son prácticamente iguales, por lo que American Aerlines fue la que más retrasos tuvo en las llegadas. Por otro lado, es lógico que si un vuelo se retrasa en la salida, se retrase también en la llegada.  

```{r,echo=TRUE,eval=TRUE}
vuelos_reduc %>% 
  filter( RETRASO_TOTAL>0) %>%
  ggplot(aes(DEPARTURE_HOUR,fill=RETRASO_TOTAL))+geom_bar() +labs(x="DEPARTURE_HOUR", y="RETRASO_TOTAL")+ guides(fill=guide_legend(title=""))+ scale_fill_manual(values=c("black","#008000"))+ggtitle("Retraso por Hora Salida")
```
  
En cuanto al retraso por hora de salida, podemos identificar que las horas más problemáticas se tienen en la franja entre las 6am y las 7pm, siendo las 6am, las 10am y las 5pm las horas que acumulan mayor retraso.   
    
```{r,echo=TRUE,eval=TRUE}
vuelos_reduc %>% 
  filter( RETRASO_TOTAL>0) %>%
  ggplot(aes(DAY_OF_WEEK,fill=RETRASO_TOTAL))+geom_bar() +labs(x="DAY_OF_WEEK", y="RETRASO_TOTAL")+ guides(fill=guide_legend(title=""))+ scale_fill_manual(values=c("black","#008000"))+ggtitle("Retraso por Día de la Semana")
```
  
Según el gráfico podemos decir que los días donde se concentra el mayor número de retrasos son el jueves y el viernes. Según esto, el mejor día para viajar sería el sábado.  
    
```{r,echo=TRUE,eval=TRUE}
vuelos_reduc %>% 
  filter( RETRASO_TOTAL>0) %>%
  ggplot(aes(MONTH,fill=RETRASO_TOTAL))+geom_bar() +labs(x="MONTH", y="RETRASO_TOTAL")+ guides(fill=guide_legend(title=""))+ scale_fill_manual(values=c("black","#008000"))+ggtitle("Retraso por Meses")
```  
  
Según el gráfico, parece que el mes con más retrasos es enero, algo que no es lo que podríamos esperar en un inicio, tendríamos que hacer un estudio de las causas de los retrasos para poder valorar bien este dato. Los mejores meses para viajar parecen ser los meses de septiembre, octubre y noviembre.  
  
```{r,echo=TRUE,eval=TRUE}
vuelos_reduc %>% 
  filter( RETRASO_TOTAL>0 & DISTANCE<2000) %>%
  ggplot(aes(DISTANCE,fill=RETRASO_TOTAL))+geom_bar() +labs(x="DISTANCE", y="RETRASO_TOTAL")+ guides(fill=guide_legend(title=""))+ scale_fill_manual(values=c("black","#008000"))+ggtitle("Retraso por Distancias")
```  
  
Comprobamos que los mayores retrasos se tienen en distancias más cortas, distancias menores de 1000 millas, y se tienen picos de retraso en distancias menores de 500 millas. Vamos a centrar un poco más el gráfico para comprobar que distancias dan esos picos de retraso.  
   
```{r,echo=TRUE,eval=TRUE}
vuelos_reduc %>% 
  filter( RETRASO_TOTAL>0 & DISTANCE<500) %>%
  ggplot(aes(DISTANCE,fill=RETRASO_TOTAL))+geom_bar() +labs(x="DISTANCE", y="RETRASO_TOTAL")+ guides(fill=guide_legend(title=""))+ scale_fill_manual(values=c("black","#008000"))+ggtitle("Retraso por Distancias")
```    
   
  A continuación, vamos a ver varias gráficas que nos aportan información en % con lo que podemos sacar mejores conclusiones sobre los retrasos y las aerolíneas, aeropuertos, etc. Para ello vamos a trabajar con el conjunto original de datos, por lo que los resultados obtenidos serán los reales el año 2015.

Comenzaremos obteniendo un conjunto de datos que no contenga datos desconocidos para poder estimar los porcentajes:


```{r,echo=TRUE,eval=TRUE}
indice <- which(is.na(vuelos$AIR_SYSTEM_DELAY)) #locations of obs with missing values
vuelos_delay <- vuelos[-indice,]
dim(vuelos_delay)
```

Lo que vamos a hacer ahora es ver los vuelos que no sufren retrasos de nuestro dataset.

```{r,echo=TRUE,eval=TRUE}
vuelos_no_delay <- vuelos[indice,]
dim(vuelos_no_delay)
```

Tenemos 1063439 vuelos que sufrieron retrasos frente a los 4755640 que no sufrieron retrasos, por lo que la probabilidad de que un vuelo se retrasara en el 2015 fue del 18.27%


Ahora, mostraremos una gráfica de barras donde podemos ver el porcentaje de retrasos de cada aerolínea:

```{r,echo=TRUE,eval=TRUE}
barplot(table(vuelos_delay$AIRLINE) / table(vuelos$AIRLINE) * 100)
```

Vemos que la que mayor porcentaje de vuelos retrasados tiene es NK. Esta gráfica nos aporta una información más valiosa que la anterior donde veíamos los retrasos totales por compañías, ya que en la anterior obteníamos que la que más retrasos registraba era AA, pero este dato se debía a que es la compañía que más opera en Estados Unidos.


Los porcentajes exactos los vemos en la siguiente tabla:

```{r,echo=TRUE,eval=TRUE}
table(vuelos_delay$AIRLINE) / table(vuelos$AIRLINE) * 100
```


Apreciamos que NK tiene un 29.15 % de vuelos retrasados, frente al 11.29 de HA que es la que menor porcentaje presenta.


Ahora lo que analizaremos será el porcentaje de vuelos retrasados según los meses:

```{r,echo=TRUE,eval=TRUE}
barplot(table(vuelos_delay$MONTH) / table(vuelos$MONTH) * 100)
table(vuelos_delay$MONTH) / table(vuelos$MONTH) * 100
```


Vemos como el mes de junio es el que presenta más retrasos. Un dato curioso que obtenemos de esta gráfica es que observamos que el mes con mayor % de retrasos no se corresponde con el mes con mayor número de vuelos. En una gráfica anterior podíamos ver como julio fue el mes con mayor número de vuelos en el año 2015 en Estados Unidos.

Ya que con los meses hemos obtenido resultados que no esperábamos, vamos a ver si con los días de la semana ocurre lo mismo. Recordemos que era el jueves el día de la semana con mayor número de vuelos:

```{r,echo=TRUE,eval=TRUE}
barplot(table(vuelos_delay$DAY_OF_WEEK) / table(vuelos$DAY_OF_WEEK) * 100)
table(vuelos_delay$DAY_OF_WEEK) / table(vuelos$DAY_OF_WEEK) * 100
```

En esta ocasión obtenemos el resultado esperado: el jueves es el día con mayor % de vuelos retrasados, lo que es lógico al ser el día de la semana con mayor número de vuelos.


Lo que vamos a mostrar en la siguiente gráfica son las franjas horarias donde se producen los retrasos:

```{r,echo=TRUE,eval=TRUE}
barplot(table(vuelos_delay$ARRIVAL_TIME) / table(vuelos$ARRIVAL_TIME) * 100)

```

Vemos que las franjas horarias donde hay mayor porcentaje de retrasos es de 1 a 5 de la madrugada, coincidiendo con el menor número de vuelos. Mientras que cuando menos retrasos se producen es de 7 a 8, que coincide con el mayor número de vuelos. Este resultado es lógico, ya que a mayor volumen de tráfico aéreo, más puntuales deben de ser porque un retraso podría tener efecto cadena, por lo que en las horas puntas debe haber una mayor puntualidad.



Otro dato curioso que podemos obtener es ver el porcentaje de vuelos retrasados según el aeropuerto del que despegan:



```{r,echo=TRUE,eval=TRUE}
t <- sort(table(vuelos_delay$ORIGIN_AIRPORT) / table(vuelos$ORIGIN_AIRPORT) * 100, decreasing = TRUE)

head(t)
```


Mostramos los 5 valores mayores y vemos como el aeropuerto con mayor porcentaje de vuelos retrasado es el de GST con un 44.15% 


Ahora haremos lo mismo pero según el aeropuerto de destino:


```{r,echo=TRUE,eval=TRUE}
t1 <- sort(table(vuelos_delay$DESTINATION_AIRPORT) / table(vuelos$DESTINATION_AIRPORT) * 100, decreasing = TRUE)

head(t1)
```


En esta ocasión es el aeropuerto de STC el que presenta un mayor porcentaje con un 36.53%.

Por lo tanto, las conclusiones que podemos sacar de estas últimas gráficas es que para reducir la posibilidad de que nuestro vuelo sufriera un retraso en el año 2015 deberíamos haber evitado volar desde el aeropuerto de GST (Gustavus Airport), que el aeropuerto de destino no fuera el de STC (St. Cloud Regional Airport), que la aerolínea no fuera NK (Spirit Air Lines) y, no volar un jueves de junio.  


******   
<h1><span style="color:darkblue"> **6. Resolución del problema**</span></h1>  
******   

**A partir de los resultados obtenidos, ¿cuáles son las conclusiones? ¿Los resultados permiten responder al problema?**


Aunque durante el desarrollo de la práctica hemos ido analizando los resultados obtenidos, en este apartado vamos a responder a una serie de preguntas a modo resumen:
- ¿Son más los vuelos retrasados que los que llegan en hora? ¿Probabilidades?
  Los vuelos retrasados en el 2015 fueron 1063439, frente a los 4755640 que llegaron a su hora, por lo que la probabilidad de que un vuelo se retrasara es del 18.27%
  
- ¿Qué aeropuerto evitar?
  El aeropuerto que debemos evitar a la hora de coger un vuelo es el de GST (Gustavus Airport), mientras que el aeropuerto de llegada a evitar es el STC (St. Cloud Regional Airport).

- ¿Qué aerolínea evitar?
  La aerolínea NK (Spirit Air Lines) es la que mayor porcentaje de vuelos retrasados presenta.
  
- ¿Qué meses, días, horas son los mejores y los peores para viajar para evitar retrasos?
  El peor mes es junio, mientras que el mejor es octubre
  El peor día es el jueves, mientras que el mejor es el sábado
  Las peores horas son de 1 a 5 de la madrugada, mientras que las mejores son de 7 a 8 de la mañana.
  
- ¿Es más fácil tener retrasos en vuelos cortos o en vuelos largos?


******   
<h1><span style="color:darkblue"> **7. Código**</span></h1>  
******   

**Adjuntar el código con el que se ha realizado la limpieza, análisis y representación de los datos.**

```{r}





```




******   
<h1><span style="color:darkblue"> **8. Contribuciones al trabajo**</span></h1>  
******   

<div style="text-align: center">![](Contribucciones.PNG) </div>



  
    
  
#<span style="color:darkblue"> Referencias: </span>  

<https://rpubs.com>  
<https://www.kaggle.com/usdot/flight-delays>




</div>
